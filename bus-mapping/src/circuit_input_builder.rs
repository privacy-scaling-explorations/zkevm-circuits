//! This module contains the CircuitInputBuilder, which is an object that takes
//! types from geth / web3 and outputs the circuit inputs.
use crate::eth_types::{
    self, Address, ChainConstants, GethExecStep, GethExecTrace, Hash,
    ToAddress, ToBigEndian, Word,
};
use crate::evm::{Gas, GasCost, GlobalCounter, OpcodeId, ProgramCounter};
use crate::exec_trace::OperationRef;
use crate::geth_errors::*;
use crate::operation::container::OperationContainer;
use crate::operation::RW;
use crate::operation::{Op, Operation};
use crate::state_db::StateDB;
use crate::Error;
use core::fmt::Debug;
use ethers_core::utils::{get_contract_address, get_create2_address};
use std::collections::{hash_map::Entry, HashMap, HashSet};

/// Out of Gas errors by opcode
#[derive(Debug, PartialEq)]
pub enum OogError {
    /// Out of Gas for opcodes which have non-zero constant gas cost
    Constant,
    /// Out of Gas for opcodes MLOAD, MSTORE, MSTORE8, CREATE, RETURN, REVERT,
    /// which have pure memory expansion gas cost
    PureMemory,
    /// Out of Gas for SHA3
    Sha3,
    /// Out of Gas for CALLDATACOPY
    CallDataCopy,
    /// Out of Gas for CODECOPY
    CodeCopy,
    /// Out of Gas for EXTCODECOPY
    ExtCodeCopy,
    /// Out of Gas for RETURNDATACOPY
    ReturnDataCopy,
    /// Out of Gas for LOG
    Log,
    /// Out of Gas for CALL
    Call,
    /// Out of Gas for CALLCODE
    CallCode,
    /// Out of Gas for DELEGATECALL
    DelegateCall,
    /// Out of Gas for CREATE2
    Create2,
    /// Out of Gas for STATICCALL
    StaticCall,
}

/// EVM Execution Error
#[derive(Debug, PartialEq)]
pub enum ExecError {
    /// Always returned for REVERT
    ExecutionReverted,
    /// Invalid Opcode
    InvalidOpcode,
    /// For opcodes who push more than pop
    StackOverflow,
    /// For opcodes which pop, DUP and SWAP, which peek deeper element directly
    StackUnderflow,
    /// Out of Gas
    OutOfGas(OogError),
    /// For SSTORE, LOG0, LOG1, LOG2, LOG3, LOG4, CREATE, CALL, CREATE2,
    /// SELFDESTRUCT
    WriteProtection,
    /// For CALL, CALLCODE, DELEGATECALL, STATICCALL
    Depth,
    /// For CALL, CALLCODE
    InsufficientBalance,
    /// For CREATE, CREATE2
    ContractAddressCollision,
    /// contract must not begin with 0xef due to EIP #3541 EVM Object Format
    /// (EOF)
    InvalidCode,
    /// For JUMP, JUMPI
    InvalidJump,
    /// For RETURNDATACOPY
    ReturnDataOutOfBounds,
    // NOTE: We don't use the GasUintOverflow in favour of always reporting an
    // OutOfGas error.
    // /// Internal calculation of gas overflow
    // GasUintOverflow,
    /// For RETURN in a CREATE, CREATE2
    CodeStoreOutOfGas,
    /// For RETURN in a CREATE, CREATE2
    MaxCodeSizeExceeded,
}

/// An execution step of the EVM.
#[derive(Debug)]
pub struct ExecStep {
    /// The opcode ID
    pub op: OpcodeId,
    /// Program Counter
    pub pc: ProgramCounter,
    /// Stack size
    pub stack_size: usize,
    /// Memory size
    pub memory_size: usize,
    /// Gas left
    pub gas_left: Gas,
    /// Gas cost of the step.  If the error is OutOfGas caused by a "gas uint64
    /// overflow", this value will **not** be the actual Gas cost of the
    /// step.
    pub gas_cost: GasCost,
    /// Call index within the [`Transaction`]
    pub call_index: usize,
    /// The global counter when this step was executed.
    pub gc: GlobalCounter,
    /// State Write Counter.  Counter of state write operations in the call
    /// that haven't been reverted yet up to this step.
    pub swc: usize,
    /// The list of references to Operations in the container
    pub bus_mapping_instance: Vec<OperationRef>,
    /// Error generated by this step
    pub error: Option<ExecError>,
    /// The step has been reverted
    pub reverted: bool,
}

impl ExecStep {
    /// Create a new Self from a [`GethExecStep`].
    pub fn new(
        step: &GethExecStep,
        call_index: usize,
        gc: GlobalCounter,
        swc: usize, // State Write Counter
    ) -> Self {
        ExecStep {
            op: step.op,
            pc: step.pc,
            stack_size: step.stack.0.len(),
            memory_size: step.memory.0.len(),
            gas_left: step.gas,
            gas_cost: step.gas_cost,
            call_index,
            gc,
            swc,
            bus_mapping_instance: Vec::new(),
            error: None,
            reverted: false,
        }
    }
}

/// Context of a [`Block`] which can mutate in a [`Transaction`].
#[derive(Debug)]
pub struct BlockContext {
    /// Used to track the global counter in every operation in the block.
    pub gc: GlobalCounter,
}

impl Default for BlockContext {
    fn default() -> Self {
        Self::new()
    }
}

impl BlockContext {
    /// Create a new Self
    pub fn new() -> Self {
        Self {
            gc: GlobalCounter::new(),
        }
    }
}

/// Circuit Input related to a block.
#[derive(Debug)]
pub struct Block {
    /// Constants associated to this block and the chain.
    pub constants: ChainConstants,
    /// Container of operations done in this block.
    pub container: OperationContainer,
    txs: Vec<Transaction>,
    code: HashMap<Hash, Vec<u8>>,
}

impl Block {
    /// Create a new block.
    pub fn new<TX>(
        _eth_block: &eth_types::Block<TX>,
        constants: ChainConstants,
    ) -> Self {
        Self {
            constants,
            container: OperationContainer::new(),
            txs: Vec::new(),
            code: HashMap::new(),
        }
    }

    /// Return the list of transactions of this block.
    pub fn txs(&self) -> &[Transaction] {
        &self.txs
    }

    #[cfg(test)]
    pub fn txs_mut(&mut self) -> &mut Vec<Transaction> {
        &mut self.txs
    }
}

/// Type of a *CALL*/CREATE* Function.
#[derive(Debug, PartialEq)]
pub enum CallKind {
    /// CALL
    Call,
    /// CALLCODE
    CallCode,
    /// DELEGATECALL
    DelegateCall,
    /// STATICCALL
    StaticCall,
    /// CREATE
    Create,
    /// CREATE2
    Create2,
}

impl CallKind {
    fn is_create(&self) -> bool {
        matches!(self, Self::Create | Self::Create2)
    }
}

impl TryFrom<OpcodeId> for CallKind {
    type Error = Error;

    fn try_from(op: OpcodeId) -> Result<Self, Self::Error> {
        Ok(match op {
            OpcodeId::CALL => CallKind::Call,
            OpcodeId::CALLCODE => CallKind::CallCode,
            OpcodeId::DELEGATECALL => CallKind::DelegateCall,
            OpcodeId::STATICCALL => CallKind::StaticCall,
            OpcodeId::CREATE => CallKind::Create,
            OpcodeId::CREATE2 => CallKind::Create2,
            _ => return Err(Error::OpcodeIdNotCallType),
        })
    }
}

/// Circuit Input related to an Ethereum Call
#[derive(Debug)]
pub struct Call {
    /// Type of call
    kind: CallKind,
    /// This call is being executed without write access (STATIC)
    is_static: bool,
    /// This call generated implicity by a Transaction.
    is_root: bool,
    /// Address where this call is being executed
    pub address: Address,
    /// Code Hash
    code_hash: Hash,
}

impl Call {
    /// This call is root call with tx.to == null, or op == CREATE or op ==
    /// CREATE2
    pub fn is_create(&self) -> bool {
        self.kind.is_create()
    }
}

/// Context of a [`Call`].
#[derive(Debug)]
pub struct CallContext {
    /// State Write Counter tracks the count of state write operations in the
    /// call.  When a subcall in this call succeeds, the `swc` increases by the
    /// number of successful state writes in the subcall.
    pub swc: usize,
}

#[derive(Debug)]
/// Context of a [`Transaction`] which can mutate in an [`ExecStep`].
pub struct TransactionContext {
    /// Call Stack by indices with CallContext.
    /// The call_stack will always have a fixed element at index 0 which
    /// corresponds to the call implicitly created by the transaction.
    call_stack: Vec<(usize, CallContext)>,
}

impl TransactionContext {
    /// Create a new Self.
    pub fn new(_eth_tx: &eth_types::Transaction) -> Self {
        Self {
            call_stack: vec![(0, CallContext { swc: 0 })],
        }
    }

    /// Return the index and context of the current call (the last call in the
    /// call stack).
    fn call_index(&self) -> usize {
        let (index, _) = self.call_stack.last().expect("call_stack is empty");
        *index
    }

    fn call_ctx(&self) -> &CallContext {
        let (_, call_ctx) =
            self.call_stack.last().expect("call_stack is empty");
        call_ctx
    }

    fn call_ctx_mut(&mut self) -> &mut CallContext {
        let (_, ref mut call_ctx) =
            self.call_stack.last_mut().expect("call_stack is empty");
        call_ctx
    }

    /// Push a new call index and context into the call stack.
    fn push_call_index_ctx(&mut self, index: usize, call_ctx: CallContext) {
        self.call_stack.push((index, call_ctx));
    }

    /// Pop the last entry in the call stack.
    fn pop_call_index_ctx(&mut self) -> Option<(usize, CallContext)> {
        self.call_stack.pop()
    }
}

#[derive(Debug)]
/// Result of the parsing of an Ethereum Transaction.
pub struct Transaction {
    /// Nonce
    pub nonce: u64,
    /// Gas
    pub gas: u64,
    /// From / Caller Address
    pub from: Address, // caller_address
    /// To / Callee Address
    pub to: Address, // callee_address
    /// Value
    pub value: Word,
    /// Input / Call Data
    pub input: Vec<u8>, // call_data
    calls: Vec<Call>,
    steps: Vec<ExecStep>,
}

impl Transaction {
    /// Create a new Self.
    pub fn new(eth_tx: &eth_types::Transaction) -> Self {
        let mut calls = Vec::new();
        let code_hash = Hash::zero();
        if let Some(address) = eth_tx.to {
            calls.push(Call {
                kind: CallKind::Call,
                is_static: false,
                is_root: true,
                address,
                code_hash,
            });
        } else {
            calls.push(Call {
                kind: CallKind::Create,
                is_static: false,
                is_root: true,
                address: Address::zero(),
                code_hash,
            });
        }
        Self {
            nonce: eth_tx.nonce.as_u64(),
            gas: eth_tx.gas.as_u64(),
            from: eth_tx.from,
            to: eth_tx.to.unwrap_or_default(),
            value: eth_tx.value,
            input: eth_tx.input.to_vec(),

            calls,
            steps: Vec::new(),
        }
    }

    /// Wether this [`Transaction`] is a create one
    pub fn is_create(&self) -> bool {
        self.calls[0].is_create()
    }

    /// Return the list of execution steps of this transaction.
    pub fn steps(&self) -> &[ExecStep] {
        &self.steps
    }

    #[cfg(test)]
    pub fn steps_mut(&mut self) -> &mut Vec<ExecStep> {
        &mut self.steps
    }

    fn push_call(
        &mut self,
        parent_index: usize,
        kind: CallKind,
        address: Address,
    ) -> usize {
        let is_static =
            kind == CallKind::StaticCall || self.calls[parent_index].is_static;
        let code_hash = Hash::zero();
        self.calls.push(Call {
            kind,
            is_static,
            is_root: false,
            address,
            code_hash,
        });
        self.calls.len() - 1
    }
}

/// Reference to the internal state of the CircuitInputBuilder in a particular
/// [`ExecStep`].
pub struct CircuitInputStateRef<'a> {
    /// StateDB
    pub sdb: &'a mut StateDB,
    /// Block
    pub block: &'a mut Block,
    /// Block Context
    pub block_ctx: &'a mut BlockContext,
    /// Transaction
    pub tx: &'a mut Transaction,
    /// Transaction Context
    pub tx_ctx: &'a mut TransactionContext,
    /// Step
    pub step: &'a mut ExecStep,
}

/// Helper function to push a call into a Transaction and TransactionContext
fn push_call(
    tx: &mut Transaction,
    tx_ctx: &mut TransactionContext,
    kind: CallKind,
    address: Address,
) {
    let parent_index = tx_ctx.call_index();
    let index = tx.push_call(parent_index, kind, address);
    tx_ctx.push_call_index_ctx(index, CallContext { swc: 0 });
}

impl<'a> CircuitInputStateRef<'a> {
    /// Push an [`Operation`] into the [`OperationContainer`] with the next
    /// [`GlobalCounter`] and then adds a reference to the stored operation
    /// ([`OperationRef`]) inside the bus-mapping instance of the current
    /// [`ExecStep`].  Then increase the block_ctx [`GlobalCounter`] by one.
    pub fn push_op<T: Op>(&mut self, op: T) {
        let op_ref = self
            .block
            .container
            .insert(Operation::new(self.block_ctx.gc.inc_pre(), op));
        self.step.bus_mapping_instance.push(op_ref);
    }

    /// Reference to the current Call
    pub fn call(&self) -> &Call {
        &self.tx.calls[self.tx_ctx.call_index()]
    }

    /// Reference to the current CallContext
    pub fn call_ctx(&self) -> &CallContext {
        self.tx_ctx.call_ctx()
    }

    /// Mutable reference to the current Call
    pub fn call_mut(&mut self) -> &mut Call {
        &mut self.tx.calls[self.tx_ctx.call_index()]
    }

    /// Push a new [`Call`] into the [`Transaction`], and add its index and
    /// [`CallContext`] in the `call_stack` of the [`TransactionContext`]
    pub fn push_call(&mut self, kind: CallKind, address: Address) {
        push_call(self.tx, self.tx_ctx, kind, address)
    }
}

#[derive(Debug)]
/// Builder to generate a complete circuit input from data gathered from a geth
/// instance. This structure is the centre of the crate and is intended to be
/// the only entry point to it. The `CircuitInputBuilder` works in several
/// steps:
///
/// 1. Take a [`eth_types::Block`] to build the circuit input associated with
/// the block. 2. For each [`eth_types::Transaction`] in the block, take the
/// [`eth_types::GethExecTrace`] to    build the circuit input associated with
/// each transaction, and the bus-mapping operations    associated with each
/// `eth_types::GethExecStep`] in the [`eth_types::GethExecTrace`].
///
/// The generated bus-mapping operations are:
/// [`StackOp`](crate::operation::StackOp)s,
/// [`MemoryOp`](crate::operation::MemoryOp)s and
/// [`StorageOp`](crate::operation::StorageOp), which correspond to each
/// [`OpcodeId`](crate::evm::OpcodeId)s used in each `ExecTrace` step so that
/// the State Proof witnesses are already generated on a structured manner and
/// ready to be added into the State circuit.
pub struct CircuitInputBuilder {
    /// StateDB key-value DB
    pub sdb: StateDB,
    /// Map of account codes by code hash
    pub codes: HashMap<Hash, Vec<u8>>,
    /// Block
    pub block: Block,
    /// Block Context
    pub block_ctx: BlockContext,
}

impl<'a> CircuitInputBuilder {
    /// Create a new CircuitInputBuilder from the given `eth_block` and
    /// `constants`.
    pub fn new<TX>(
        eth_block: &eth_types::Block<TX>,
        constants: ChainConstants,
    ) -> Self {
        Self {
            sdb: StateDB::new(),
            codes: HashMap::new(),
            block: Block::new(eth_block, constants),
            block_ctx: BlockContext::new(),
        }
    }

    /// Obtain a mutable reference to the state that the `CircuitInputBuilder`
    /// maintains, contextualized to a particular transaction and a
    /// particular execution step in that transaction.
    pub fn state_ref(
        &'a mut self,
        tx: &'a mut Transaction,
        tx_ctx: &'a mut TransactionContext,
        step: &'a mut ExecStep,
    ) -> CircuitInputStateRef {
        CircuitInputStateRef {
            sdb: &mut self.sdb,
            block: &mut self.block,
            block_ctx: &mut self.block_ctx,
            tx,
            tx_ctx,
            step,
        }
    }

    /// Handle a transaction with its corresponding execution trace to generate
    /// all the associated operations.  Each operation is registered in
    /// `self.block.container`, and each step stores the [`OperationRef`] to
    /// each of the generated operations.
    pub fn handle_tx(
        &mut self,
        eth_tx: &eth_types::Transaction,
        geth_trace: &GethExecTrace,
    ) -> Result<(), Error> {
        let mut tx = Transaction::new(eth_tx);
        let mut tx_ctx = TransactionContext::new(eth_tx);
        for (index, geth_step) in geth_trace.struct_logs.iter().enumerate() {
            let mut step = ExecStep::new(
                geth_step,
                tx_ctx.call_index(),
                self.block_ctx.gc,
                tx_ctx.call_ctx().swc,
            );
            let mut state_ref = self.state_ref(&mut tx, &mut tx_ctx, &mut step);
            geth_step.op.gen_associated_ops(
                &mut state_ref,
                &geth_trace.struct_logs[index..],
            )?;

            if let Some(geth_next_step) = geth_trace.struct_logs.get(index + 1)
            {
                if geth_step.depth + 1 == geth_next_step.depth {
                    // Handle *CALL*/CREATE*
                    let address = state_ref.call_address(geth_step)?;
                    let kind = CallKind::try_from(geth_step.op)?;
                    push_call(&mut tx, &mut tx_ctx, kind, address);
                } else if geth_step.depth - 1 == geth_next_step.depth {
                    // Handle *CALL*/CREATE* return
                    if tx_ctx.call_stack.len() == 1 {
                        return Err(Error::InvalidGethExecStep(
                            "handle_tx: call stack will be empty",
                            Box::new(geth_step.clone()),
                        ));
                    }
                    let (_, call_ctx) = tx_ctx
                        .pop_call_index_ctx()
                        .expect("call stack is empty");
                    // If the return was successful, accumulate the swc from the
                    // subcall.
                    if !geth_next_step.stack.last()?.is_zero() {
                        tx_ctx.call_ctx_mut().swc += call_ctx.swc;
                    }
                }
            }
            tx.steps.push(step);
        }
        self.block.txs.push(tx);
        Ok(())
    }
}

fn get_step_reported_error(op: &OpcodeId, error: &str) -> ExecError {
    if error == GETH_ERR_WRITE_PROTECTION {
        ExecError::WriteProtection
    } else if error == GETH_ERR_OUT_OF_GAS
        || error == GETH_ERR_GAS_UINT_OVERFLOW
    {
        // NOTE: We report a GasUintOverflow error as an OutOfGas error
        let oog_err = match op {
            OpcodeId::SHA3 => OogError::Sha3,
            OpcodeId::CALLDATACOPY => OogError::CallDataCopy,
            OpcodeId::CODECOPY => OogError::CodeCopy,
            OpcodeId::EXTCODECOPY => OogError::ExtCodeCopy,
            OpcodeId::RETURNDATACOPY => OogError::ReturnDataCopy,
            OpcodeId::LOG0
            | OpcodeId::LOG2
            | OpcodeId::LOG3
            | OpcodeId::LOG4 => OogError::Log,
            OpcodeId::CALL => OogError::Call,
            OpcodeId::CALLCODE => OogError::CallCode,
            OpcodeId::DELEGATECALL => OogError::DelegateCall,
            OpcodeId::CREATE2 => OogError::Create2,
            OpcodeId::STATICCALL => OogError::StaticCall,
            OpcodeId::MLOAD
            | OpcodeId::MSTORE
            | OpcodeId::MSTORE8
            | OpcodeId::CREATE
            | OpcodeId::RETURN
            | OpcodeId::REVERT => OogError::PureMemory,
            _ => OogError::Constant,
        };
        ExecError::OutOfGas(oog_err)
    } else if error.starts_with(GETH_ERR_STACK_OVERFLOW) {
        ExecError::StackOverflow
    } else if error.starts_with(GETH_ERR_STACK_UNDERFLOW) {
        ExecError::StackUnderflow
    } else if error.starts_with(GETH_ERR_INVALID_OPCODE) {
        ExecError::InvalidOpcode
    } else {
        panic!("Unknown GethExecStep.error: {}", error);
    }
}

/// Retreive the init_code from memory for {CREATE, CREATE2}
pub fn get_create_init_code(step: &GethExecStep) -> Result<&[u8], Error> {
    let offset = step.stack.nth_last(1)?;
    let length = step.stack.nth_last(2)?;
    Ok(&step.memory.0[offset.low_u64() as usize
        ..(offset.low_u64() + length.low_u64()) as usize])
}

impl<'a> CircuitInputStateRef<'a> {
    /// Return the contract address of a CREATE step.  This is calculated by
    /// inspecting the current address and its nonce from the StateDB.
    fn create_address(&self) -> Result<Address, Error> {
        let sender = self.call().address;
        let (found, account) = self.sdb.get_account(&sender);
        if !found {
            return Err(Error::AccountNotFound(sender));
        }
        Ok(get_contract_address(sender, account.nonce))
    }

    /// Return the contract address of a CREATE2 step.  This is calculated
    /// deterministically from the arguments in the stack.
    fn create2_address(&self, step: &GethExecStep) -> Result<Address, Error> {
        let salt = step.stack.nth_last(3)?;
        let init_code = get_create_init_code(step)?;
        Ok(get_create2_address(
            self.call().address,
            salt.to_be_bytes().to_vec(),
            init_code.to_vec(),
        ))
    }

    /// Return the contract address of a *CALL*/CREATE* step.
    fn call_address(&self, step: &GethExecStep) -> Result<Address, Error> {
        Ok(match step.op {
            OpcodeId::CALL
            | OpcodeId::CALLCODE
            | OpcodeId::DELEGATECALL
            | OpcodeId::STATICCALL => step.stack.nth_last(1)?.to_address(),
            OpcodeId::CREATE => self.create_address()?,
            OpcodeId::CREATE2 => self.create2_address(step)?,
            _ => return Err(Error::OpcodeIdNotCallType),
        })
    }

    fn get_step_err(
        &self,
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> Result<Option<ExecError>, Error> {
        if let Some(error) = &step.error {
            return Ok(Some(get_step_reported_error(&step.op, error)));
        }

        // When last step is RETURN or STOP there's no error.
        if matches!(next_step, None)
            && matches!(step.op, OpcodeId::RETURN | OpcodeId::STOP)
        {
            return Ok(None);
        }

        let next_depth = next_step.map(|s| s.depth).unwrap_or(0);
        let next_result = next_step
            .map(|s| s.stack.last().unwrap_or_else(|_| Word::zero()))
            .unwrap_or_else(Word::zero);

        // Return from a call with a failure
        if step.depth != next_depth && next_result.is_zero() {
            if !matches!(step.op, OpcodeId::RETURN) {
                // Without calling RETURN
                return Ok(Some(match step.op {
                    OpcodeId::REVERT => ExecError::ExecutionReverted,
                    OpcodeId::JUMP | OpcodeId::JUMPI => ExecError::InvalidJump,
                    OpcodeId::RETURNDATACOPY => {
                        ExecError::ReturnDataOutOfBounds
                    }
                    _ => {
                        return Err(Error::UnexpectedExecStepError(
                            "call failure without return",
                            Box::new(step.clone()),
                        ));
                    }
                }));
            } else {
                // Calling RETURN
                let call = self.call();

                // Return from a {CREATE, CREATE2} with a failure, via RETURN
                if !call.is_root && call.is_create() {
                    let offset = step.stack.nth_last(0)?;
                    let length = step.stack.nth_last(1)?;
                    if length > Word::from(0x6000u64) {
                        return Ok(Some(ExecError::MaxCodeSizeExceeded));
                    } else if length > Word::zero()
                        && !step.memory.0.is_empty()
                        && step.memory.0.get(offset.low_u64() as usize)
                            == Some(&0xef)
                    {
                        return Ok(Some(ExecError::InvalidCode));
                    } else if Word::from(200u64) * length
                        > Word::from(step.gas.0)
                    {
                        return Ok(Some(ExecError::CodeStoreOutOfGas));
                    } else {
                        return Err(Error::UnexpectedExecStepError(
                            "failure in RETURN from {CREATE, CREATE2}",
                            Box::new(step.clone()),
                        ));
                    }
                } else {
                    return Err(Error::UnexpectedExecStepError(
                        "failure in RETURN",
                        Box::new(step.clone()),
                    ));
                }
            }
        }

        // Return from a call via RETURN or STOP and having a success result is
        // OK.

        // Return from a call without calling RETURN or STOP and having success
        // is unexpected.
        if step.depth != next_depth
            && next_result != Word::zero()
            && !matches!(step.op, OpcodeId::RETURN | OpcodeId::STOP)
        {
            return Err(Error::UnexpectedExecStepError(
                "success result without {RETURN, STOP}",
                Box::new(step.clone()),
            ));
        }

        // The *CALL*/CREATE* code was not executed
        let next_pc = next_step.map(|s| s.pc.0).unwrap_or(1);
        if matches!(
            step.op,
            OpcodeId::CALL
                | OpcodeId::CALLCODE
                | OpcodeId::DELEGATECALL
                | OpcodeId::STATICCALL
                | OpcodeId::CREATE
                | OpcodeId::CREATE2
        ) && next_result.is_zero()
            && next_pc != 0
        {
            if step.depth == 1025 {
                return Ok(Some(ExecError::Depth));
            }

            // Insufficient_balance
            let value = match step.op {
                OpcodeId::CALL | OpcodeId::CALLCODE => {
                    step.stack.nth_last(2)?
                }
                OpcodeId::CREATE | OpcodeId::CREATE2 => {
                    step.stack.nth_last(0)?
                }
                _ => Word::zero(),
            };
            let sender = self.call().address;
            let (found, account) = self.sdb.get_account(&sender);
            if !found {
                return Err(Error::AccountNotFound(sender));
            }
            if account.balance < value {
                return Ok(Some(ExecError::InsufficientBalance));
            }

            // Address collision
            if matches!(step.op, OpcodeId::CREATE | OpcodeId::CREATE2) {
                let address = match step.op {
                    OpcodeId::CREATE => self.create_address()?,
                    OpcodeId::CREATE2 => self.create2_address(step)?,
                    _ => unreachable!(),
                };
                let (found, _) = self.sdb.get_account(&address);
                if found {
                    return Ok(Some(ExecError::ContractAddressCollision));
                }
            }

            return Err(Error::UnexpectedExecStepError(
                "*CALL*/CREATE* code not executed",
                Box::new(step.clone()),
            ));
        }

        Ok(None)
    }
}

/// State and Code Access with "keys/index" used in the access operation.
#[derive(Debug, PartialEq)]
pub enum AccessValue {
    /// Account access
    Account {
        /// Account address
        address: Address,
    },
    /// Storage access
    Storage {
        /// Storage account address
        address: Address,
        /// Storage key
        key: Word,
    },
    /// Code access
    Code {
        /// Code address
        address: Address,
    },
}

/// State Access caused by a transaction or an execution step
#[derive(Debug, PartialEq)]
pub struct Access {
    step_index: Option<usize>,
    rw: RW,
    value: AccessValue,
}

impl Access {
    fn new(step_index: Option<usize>, rw: RW, value: AccessValue) -> Self {
        Self {
            step_index,
            rw,
            value,
        }
    }
}

/// Given a trace and assuming that the first step is a *CALL*/CREATE* kind
/// opcode, return the result if found.
fn get_call_result(trace: &[GethExecStep]) -> Option<Word> {
    let depth = trace[0].depth;
    trace[1..]
        .iter()
        .find(|s| s.depth == depth)
        .map(|s| s.stack.nth_last(0).ok())
        .flatten()
}

/// State and Code Access set.
#[derive(Debug, PartialEq)]
pub struct AccessSet {
    /// Set of accounts
    pub state: HashMap<Address, HashSet<Word>>,
    /// Set of accounts code
    pub code: HashSet<Address>,
}

impl From<Vec<Access>> for AccessSet {
    fn from(list: Vec<Access>) -> Self {
        let mut state: HashMap<Address, HashSet<Word>> = HashMap::new();
        let mut code: HashSet<Address> = HashSet::new();
        for access in list {
            match access.value {
                AccessValue::Account { address } => {
                    state.entry(address).or_insert_with(HashSet::new);
                }
                AccessValue::Storage { address, key } => {
                    match state.entry(address) {
                        Entry::Vacant(entry) => {
                            let mut storage = HashSet::new();
                            storage.insert(key);
                            entry.insert(storage);
                        }
                        Entry::Occupied(mut entry) => {
                            entry.get_mut().insert(key);
                        }
                    }
                }
                AccessValue::Code { address } => {
                    code.insert(address);
                }
            }
        }
        Self { state, code }
    }
}

/// Source of the code in the EVM execution.
#[derive(Clone, Copy)]
pub enum CodeSource {
    /// Code comes from a deployed contract at `Address`.
    Address(Address),
    /// Code comes from tx.data when tx.to == null.
    Tx,
    /// Code comes from Memory by a CREATE* opcode.
    Memory,
}

/// Generate the State Access trace from the given trace.  All state read/write
/// accesses are reported, without distinguishing those that happen in revert
/// sections.
pub fn gen_state_access_trace<TX>(
    _block: &eth_types::Block<TX>,
    tx: &eth_types::Transaction,
    geth_trace: &GethExecTrace,
) -> Result<Vec<Access>, Error> {
    use AccessValue::{Account, Code, Storage};
    use RW::{READ, WRITE};

    let mut call_stack: Vec<(Address, CodeSource)> = Vec::new();
    let mut accs = vec![Access::new(None, WRITE, Account { address: tx.from })];
    if let Some(to) = tx.to {
        call_stack.push((to, CodeSource::Address(to)));
        accs.push(Access::new(None, WRITE, Account { address: to }));
        // Code may be null if the account is not a contract
        accs.push(Access::new(None, READ, Code { address: to }));
    } else {
        let address = get_contract_address(tx.from, tx.nonce);
        call_stack.push((address, CodeSource::Tx));
        accs.push(Access::new(None, WRITE, Account { address }));
        accs.push(Access::new(None, WRITE, Code { address }));
    }

    for (index, step) in geth_trace.struct_logs.iter().enumerate() {
        let next_step = geth_trace.struct_logs.get(index + 1);
        let i = Some(index);
        let (contract_address, code_source) = &call_stack[call_stack.len() - 1];
        let (contract_address, code_source) = (*contract_address, *code_source);
        match step.op {
            OpcodeId::SSTORE => {
                let address = contract_address;
                let key = step.stack.nth_last(0)?;
                accs.push(Access::new(i, WRITE, Storage { address, key }));
            }
            OpcodeId::SLOAD => {
                let address = contract_address;
                let key = step.stack.nth_last(0)?;
                accs.push(Access::new(i, READ, Storage { address, key }));
            }
            OpcodeId::SELFBALANCE => {
                let address = contract_address;
                accs.push(Access::new(i, READ, Account { address }));
            }
            OpcodeId::CODESIZE => {
                if let CodeSource::Address(address) = code_source {
                    accs.push(Access::new(i, READ, Code { address }));
                }
            }
            OpcodeId::CODECOPY => {
                if let CodeSource::Address(address) = code_source {
                    accs.push(Access::new(i, READ, Code { address }));
                }
            }
            OpcodeId::BALANCE => {
                let address = step.stack.nth_last(0)?.to_address();
                accs.push(Access::new(i, READ, Account { address }));
            }
            OpcodeId::EXTCODEHASH => {
                let address = step.stack.nth_last(0)?.to_address();
                accs.push(Access::new(i, READ, Account { address }));
            }
            OpcodeId::EXTCODESIZE => {
                let address = step.stack.nth_last(0)?.to_address();
                accs.push(Access::new(i, READ, Code { address }));
            }
            OpcodeId::EXTCODECOPY => {
                let address = step.stack.nth_last(0)?.to_address();
                accs.push(Access::new(i, READ, Code { address }));
            }
            OpcodeId::SELFDESTRUCT => {
                let address = contract_address;
                accs.push(Access::new(i, WRITE, Account { address }));
                let address = step.stack.nth_last(0)?.to_address();
                accs.push(Access::new(i, WRITE, Account { address }));
            }
            OpcodeId::CREATE => {
                // Find CREATE result
                let address = get_call_result(&geth_trace.struct_logs[index..])
                    .unwrap_or_else(Word::zero)
                    .to_address();
                if !address.is_zero() {
                    accs.push(Access::new(i, WRITE, Account { address }));
                    accs.push(Access::new(i, WRITE, Code { address }));
                }
            }
            OpcodeId::CREATE2 => {
                // Find CREATE2 result
                let address = get_call_result(&geth_trace.struct_logs[index..])
                    .unwrap_or_else(Word::zero)
                    .to_address();
                if !address.is_zero() {
                    accs.push(Access::new(i, WRITE, Account { address }));
                    accs.push(Access::new(i, WRITE, Code { address }));
                }
            }
            OpcodeId::CALL => {
                let address = contract_address;
                accs.push(Access::new(i, WRITE, Account { address }));

                let address = step.stack.nth_last(1)?.to_address();
                accs.push(Access::new(i, WRITE, Account { address }));
                accs.push(Access::new(i, READ, Code { address }));
                call_stack.push((address, CodeSource::Address(address)));
            }
            OpcodeId::CALLCODE => {
                let address = contract_address;
                accs.push(Access::new(i, WRITE, Account { address }));

                let address = step.stack.nth_last(1)?.to_address();
                accs.push(Access::new(i, WRITE, Account { address }));
                accs.push(Access::new(i, READ, Code { address }));
                call_stack.push((address, CodeSource::Address(address)));
            }
            OpcodeId::DELEGATECALL => {
                let address = step.stack.nth_last(1)?.to_address();
                accs.push(Access::new(i, READ, Code { address }));
                call_stack
                    .push((contract_address, CodeSource::Address(address)));
            }
            OpcodeId::STATICCALL => {
                let address = step.stack.nth_last(1)?.to_address();
                accs.push(Access::new(i, READ, Code { address }));
                call_stack.push((address, CodeSource::Address(address)));
            }
            _ => {}
        }
        if let Some(next_step) = next_step {
            // return from a *CALL*/CREATE*
            if step.depth - 1 == next_step.depth {
                if call_stack.len() == 1 {
                    return Err(Error::InvalidGethExecStep(
                        "gen_state_access_trace: call stack will be empty",
                        Box::new(step.clone()),
                    ));
                }
                call_stack.pop().expect("call stack is empty");
            }
        }
    }
    Ok(accs)
}

#[cfg(test)]
mod tracer_tests {
    use super::*;
    use crate::{
        address, bytecode,
        bytecode::Bytecode,
        eth_types::{ToWord, Word},
        evm::{stack::Stack, Gas, OpcodeId},
        mock,
        state_db::Account,
        word,
    };
    use lazy_static::lazy_static;
    use pretty_assertions::assert_eq;
    use std::iter::FromIterator;

    // Helper struct that contains a CircuitInputBuilder, a particuar tx and a
    // particular execution step so that we can easily get a
    // CircuitInputStateRef to have a context in order to get the error at a
    // given step.
    struct CircuitInputBuilderTx {
        builder: CircuitInputBuilder,
        tx: Transaction,
        tx_ctx: TransactionContext,
        step: ExecStep,
    }

    impl CircuitInputBuilderTx {
        fn new(block: &mock::BlockData, geth_step: &GethExecStep) -> Self {
            Self {
                builder: CircuitInputBuilder::new(
                    &block.eth_block,
                    block.ctants.clone(),
                ),
                tx: Transaction::new(&block.eth_tx),
                tx_ctx: TransactionContext::new(&block.eth_tx),
                step: ExecStep::new(geth_step, 0, GlobalCounter(0), 0),
            }
        }

        fn state_ref(&mut self) -> CircuitInputStateRef {
            self.builder.state_ref(
                &mut self.tx,
                &mut self.tx_ctx,
                &mut self.step,
            )
        }
    }

    lazy_static! {
        static ref ADDR_A: Address = Address::zero();
        static ref WORD_ADDR_A: Word = ADDR_A.to_word();
        static ref ADDR_B: Address =
            address!("0x0000000000000000000000000000000000000123");
        static ref WORD_ADDR_B: Word = ADDR_B.to_word();
    }

    //
    // Geth Errors ignored
    //
    // These errors happen in a CALL, CALLCODE, DELEGATECALL or STATICCALL, and
    // are used internally but not propagated in geth to the scope where the
    // tracer is used.

    fn check_err_depth(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        matches!(
            step.op,
            OpcodeId::CALL
                | OpcodeId::CALLCODE
                | OpcodeId::DELEGATECALL
                | OpcodeId::STATICCALL
                | OpcodeId::CREATE
                | OpcodeId::CREATE2
        ) && step.error.is_none()
            && result(next_step).is_zero()
            && step.depth == 1025
    }

    #[test]
    fn tracer_err_depth() {
        // Recursive CALL will exaust the call depth
        let code = bytecode! {
                 PUSH1(0x0) // retLength
                 PUSH1(0x0) // retOffset
                 PUSH1(0x0) // argsLength
                 PUSH1(0x0) // argsOffset
                 PUSH1(0x42) // value
                 PUSH32(*WORD_ADDR_A) // addr
                 PUSH32(0x8_0000_0000_0000_u64) // gas
                 CALL
                 PUSH2(0xab)
                 STOP
        };
        let block = mock::BlockData::new_single_tx_trace_code_gas(
            &code,
            Gas(1_000_000_000_000_000u64),
        )
        .unwrap();
        let struct_logs = &block.geth_trace.struct_logs;

        // get last CALL
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::CALL)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(step.op, OpcodeId::CALL);
        assert_eq!(step.depth, 1025u16);
        assert_eq!(step.error, None);
        // Some sanity checks
        assert_eq!(struct_logs[index + 1].op, OpcodeId::PUSH2);
        assert_eq!(struct_logs[index + 1].depth, 1025u16);
        assert_eq!(struct_logs[index + 1].stack, Stack(vec![Word::from(0)])); // success = 0
        assert_eq!(struct_logs[index + 2].op, OpcodeId::STOP);
        assert_eq!(struct_logs[index + 2].depth, 1025u16);

        assert!(check_err_depth(step, next_step));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::Depth)
        );
    }

    #[test]
    fn tracer_err_insufficient_balance() {
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH32(Word::from(0x1000)) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };
        let code_b = bytecode! {
            PUSH1(0x01) // value
            PUSH1(0x02) // key
            SSTORE

            PUSH3(0xbb)
        };
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last CALL
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::CALL)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(step.error, None);
        assert_eq!(next_step.unwrap().op, OpcodeId::PUSH2);
        assert_eq!(next_step.unwrap().stack, Stack(vec![Word::from(0)])); // success = 0

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        builder.builder.sdb.set_account(
            &ADDR_A,
            Account {
                nonce: Word::zero(),
                balance: Word::from(555u64), /* same value as in
                                              * `mock::new_tracer_account` */
                storage: HashMap::new(),
                code_hash: Hash::zero(),
            },
        );
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::InsufficientBalance)
        );
    }

    #[test]
    fn tracer_err_address_collision() {
        // We do CREATE2 twice with the same parameters, with a code_creater
        // that outputs the same, which will lead to the same new
        // contract address.
        let code_creator = bytecode! {
            PUSH1(0x00) // value
            PUSH1(0x00) // offset
            MSTORE
            PUSH1(0x01) // length
            PUSH1(0x00) // offset
            RETURN
        };

        // code_a calls code_b which executes code_creator in CREATE2
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH3(0x123456) // salt
            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE2

            PUSH3(0x123456) // salt
            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE2

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last CREATE2
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::CREATE2)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);

        let create2_address: Address = {
            // get first RETURN
            let (index, _) = block
                .geth_trace
                .struct_logs
                .iter()
                .enumerate()
                .find(|(_, s)| s.op == OpcodeId::RETURN)
                .unwrap();
            let next_step = block.geth_trace.struct_logs.get(index + 1);
            let addr_word = next_step.unwrap().stack.last().unwrap();
            addr_word.to_address()
        };

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        // Set up call context at CREATE2
        builder.state_ref().push_call(CallKind::Create, *ADDR_B);
        // Set up account and contract that exist during the second CREATE2
        builder.builder.sdb.set_account(
            &ADDR_B,
            Account {
                nonce: Word::zero(),
                balance: Word::from(555u64), /* same value as in
                                              * `mock::new_tracer_account` */
                storage: HashMap::new(),
                code_hash: Hash::zero(),
            },
        );
        builder.builder.sdb.set_account(
            &create2_address,
            Account {
                nonce: Word::zero(),
                balance: Word::zero(),
                storage: HashMap::new(),
                code_hash: Hash::zero(),
            },
        );
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::ContractAddressCollision)
        );
    }

    fn check_err_code_store_out_of_gas(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        let length = step.stack.nth_last(1).unwrap();
        step.op == OpcodeId::RETURN
            && step.error.is_none()
            && result(next_step).is_zero()
            && Word::from(200) * length > Word::from(step.gas.0)
    }

    #[test]
    fn tracer_err_code_store_out_of_gas() {
        // code_creator outputs an empty array of length 0x100, which will
        // exhaust the gas to store the code.
        let code_len = 0x100;
        let code_creator = bytecode! {
            PUSH1(Word::zero()) // value
            PUSH32(code_len) // offset
            MSTORE
            PUSH32(code_len) // length
            PUSH1(0x00) // offset
            RETURN
        };

        // code_a calls code_b which executes code_creator in CREATE
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH32(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last RETURN
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::RETURN)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert!(check_err_code_store_out_of_gas(step, next_step));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        // Set up call context at CREATE
        builder.state_ref().push_call(CallKind::Create, *ADDR_B);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::CodeStoreOutOfGas)
        );
    }

    fn check_err_invalid_code(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        let offset = step.stack.nth_last(0).unwrap();
        let length = step.stack.nth_last(1).unwrap();
        step.op == OpcodeId::RETURN
            && step.error.is_none()
            && result(next_step).is_zero()
            && length > Word::zero()
            && !step.memory.0.is_empty()
            && step.memory.0.get(offset.low_u64() as usize) == Some(&0xef)
    }

    #[test]
    fn tracer_err_invalid_code() {
        // code_creator outputs byte array that starts with 0xef, which is
        // invalid code.
        let code_creator = bytecode! {
            PUSH32(word!("0xef00000000000000000000000000000000000000000000000000000000000000")) // value
            PUSH1(0x00) // offset
            MSTORE
            PUSH1(0x01) // length
            PUSH1(0x00) // offset
            RETURN
        };

        // code_a calls code_b which executes code_creator in CREATE
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last RETURN
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::RETURN)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert!(check_err_invalid_code(step, next_step));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        // Set up call context at RETURN
        builder.state_ref().push_call(CallKind::Create, *ADDR_B);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::InvalidCode)
        );
    }

    fn check_err_max_code_size_exceeded(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        let length = step.stack.nth_last(1).unwrap();
        step.op == OpcodeId::RETURN
            && step.error.is_none()
            && result(next_step).is_zero()
            && length > Word::from(0x6000)
    }

    #[test]
    fn tracer_err_max_code_size_exceeded() {
        // code_creator outputs an empty array of length 0x6000 + 1, which will
        // trigger the max code size limit.
        let code_len = 0x6000 + 1;
        let code_creator = bytecode! {
            PUSH1(Word::zero()) // value
            PUSH32(code_len) // offset
            MSTORE
            PUSH32(code_len) // length
            PUSH1(0x00) // offset
            RETURN
        };

        // code_a calls code_b which executes code_creator in CREATE
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x10_0000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH32(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last RETURN
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::RETURN)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert!(check_err_max_code_size_exceeded(step, next_step));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        // Set up call context at RETURN
        builder.state_ref().push_call(CallKind::Create, *ADDR_B);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::MaxCodeSizeExceeded)
        );
    }

    #[test]
    fn tracer_create_stop() {
        // code_creator doesn't output anything because it stops.
        let code_creator = bytecode! {
            PUSH32(word!("0xef00000000000000000000000000000000000000000000000000000000000000")) // value
            PUSH1(0x00) // offset
            MSTORE
            PUSH1(0x01) // length
            PUSH1(0x00) // offset
            STOP
        };

        // code_a calls code_b which executes code_creator in CREATE
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get first STOP
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .find(|(_, s)| s.op == OpcodeId::STOP)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        // Set up call context at STOP
        builder.state_ref().push_call(CallKind::Create, *ADDR_B);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            None
        );
    }

    //
    // Geth Errors not reported
    //
    // These errors are specific to some opcodes and due to the way the tracing
    // works, they are never captured, because the trace is made before the
    // step is executed, so when these errors happen, the trace step
    // contains error = null.

    fn result(step: Option<&GethExecStep>) -> Word {
        step.map(|s| s.stack.last().unwrap_or_else(|_| Word::zero()))
            .unwrap_or_else(Word::zero)
    }

    fn check_err_invalid_jump(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        let next_depth = next_step.map(|s| s.depth).unwrap_or(0);
        matches!(step.op, OpcodeId::JUMP | OpcodeId::JUMPI)
            && step.error.is_none()
            && result(next_step).is_zero()
            && step.depth != next_depth
    }

    #[test]
    fn tracer_err_invalid_jump() {
        // jump to 0x10 which is outside the code (and also not marked with
        // JUMPDEST)
        let code = bytecode! {
            PUSH1(0x10)
            JUMP
            STOP
        };
        let index = 1; // JUMP
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();
        assert_eq!(block.geth_trace.struct_logs.len(), 2);
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert!(check_err_invalid_jump(step, next_step));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::InvalidJump)
        );

        // With CALL

        // code_a calls code
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            STATICCALL

            PUSH2(0xaa)
        };
        let index = 8; // JUMP
        let block = mock::BlockData::new_single_tx_trace_code_2(&code_a, &code)
            .unwrap();
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert!(check_err_invalid_jump(step, next_step));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::InvalidJump)
        );
    }

    fn check_err_execution_reverted(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        let next_depth = next_step.map(|s| s.depth).unwrap_or(0);
        step.op == OpcodeId::REVERT
            && step.error.is_none()
            && result(next_step).is_zero()
            && step.depth != next_depth
    }

    #[test]
    fn tracer_err_execution_reverted() {
        // Do a REVERT
        let code = bytecode! {
            PUSH1(0x0)
            PUSH2(0x0)
            REVERT
            PUSH3(0x12)
            STOP
        };
        let index = 2; // REVERT
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();
        assert_eq!(block.geth_trace.struct_logs.len(), 3);
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert!(check_err_execution_reverted(step, next_step));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::ExecutionReverted)
        );

        // With CALL

        // code_a calls code
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };
        let index = 10; // REVERT
        let block = mock::BlockData::new_single_tx_trace_code_2(&code_a, &code)
            .unwrap();
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert!(check_err_execution_reverted(step, next_step));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::ExecutionReverted)
        );
    }

    #[test]
    fn tracer_stop() {
        // Do a STOP
        let code = bytecode! {
            PUSH1(0x0)
            PUSH2(0x0)
            STOP
            PUSH3(0x12)
            STOP
        };

        // code_a calls code
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };
        let index = 10; // STOP
        let block = mock::BlockData::new_single_tx_trace_code_2(&code_a, &code)
            .unwrap();
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            None
        );
    }

    fn check_err_return_data_out_of_bounds(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        let next_depth = next_step.map(|s| s.depth).unwrap_or(0);
        step.op == OpcodeId::RETURNDATACOPY
            && step.error.is_none()
            && result(next_step).is_zero()
            && step.depth != next_depth
    }

    #[test]
    fn tracer_err_return_data_out_of_bounds() {
        // code_a calls code_b and gets the return data with a length 0x02 but
        // code_b returns data with length 0x01.
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH1(0x02) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // destOffset
            RETURNDATACOPY

            PUSH2(0xaa)
        };
        let code_b = bytecode! {
            PUSH2(0x42) // value
            PUSH2(0x00) // offset
            MSTORE
            PUSH1(0x01) // length
            PUSH1(0x00) // offset
            RETURN
        };
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last RETURNDATACOPY
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::RETURNDATACOPY)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert!(check_err_return_data_out_of_bounds(step, next_step));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::ReturnDataOutOfBounds)
        );
    }

    //
    // Geth Errors Reported
    //
    // These errors can be found in the trace step error field.

    #[test]
    fn tracer_err_gas_uint_overflow() {
        // MSTORE a value at an offset so high that the gast cost is big enough
        // to overflow an uint64
        let code = bytecode! {
            PUSH32(0x42) // value
            PUSH32(0x100_0000_0000_0000_0000_u128) // offset
            MSTORE
        };
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();

        let index = 2; // MSTORE
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(step.op, OpcodeId::MSTORE);
        assert_eq!(step.error, Some(GETH_ERR_GAS_UINT_OVERFLOW.to_string()));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::OutOfGas(OogError::PureMemory))
        );
    }

    #[test]
    fn tracer_err_invalid_opcode() {
        // The second opcode is invalid (0x0f)
        let mut code = bytecode::Bytecode::default();
        code.write_op(OpcodeId::PC);
        code.write(0x0f);
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();

        let index = block.geth_trace.struct_logs.len() - 1; // 0x0f
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(step.op, OpcodeId::INVALID(0x0f));
        assert_eq!(
            step.error,
            Some(format!(
                "{}: opcode 0xf not defined",
                GETH_ERR_INVALID_OPCODE
            ))
        );

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::InvalidOpcode)
        );
    }

    #[test]
    fn tracer_err_write_protection() {
        // code_a calls code_b via static call, which tries to SSTORE and fails.
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            STATICCALL

            PUSH2(0xaa)
        };
        let code_b = bytecode! {
            PUSH1(0x01) // value
            PUSH1(0x02) // key
            SSTORE

            PUSH3(0xbb)
        };
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        let index = 9; // SSTORE
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(step.op, OpcodeId::SSTORE);
        assert_eq!(step.error, Some(GETH_ERR_WRITE_PROTECTION.to_string()));

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::WriteProtection)
        );
    }

    #[test]
    fn tracer_err_out_of_gas() {
        // Do 3 PUSH1 with gas = 4, which causes out of gas
        let code = bytecode! {
            PUSH1(0x0)
            PUSH1(0x1)
            PUSH1(0x2)
        };
        let block =
            mock::BlockData::new_single_tx_trace_code_gas(&code, Gas(4))
                .unwrap();
        let struct_logs = block.geth_trace.struct_logs;

        assert_eq!(struct_logs[1].error, Some(GETH_ERR_OUT_OF_GAS.to_string()));
    }

    #[test]
    fn tracer_err_stack_overflow() {
        // PUSH2 1025 times, causing a stack overflow
        let mut code = bytecode::Bytecode::default();
        for i in 0..1025 {
            code.push(2, Word::from(i));
        }
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();

        let index = block.geth_trace.struct_logs.len() - 1; // PUSH2
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(
            step.error,
            Some(format!("{} 1024 (1023)", GETH_ERR_STACK_OVERFLOW))
        );

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::StackOverflow)
        );
    }

    #[test]
    fn tracer_err_stack_underflow() {
        // SWAP5 with an empty stack, which causes a stack underflow
        let code = bytecode! {
            SWAP5
        };
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();

        let index = 0; // SWAP5
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(
            step.error,
            Some(format!("{} (0 <=> 6)", GETH_ERR_STACK_UNDERFLOW))
        );

        let mut builder = CircuitInputBuilderTx::new(&block, step);
        assert_eq!(
            builder.state_ref().get_step_err(step, next_step).unwrap(),
            Some(ExecError::StackUnderflow)
        );
    }

    //
    // Circuit Input Builder tests
    //

    #[test]
    fn create2_address() {
        // code_creator outputs 0x6050.
        let code_creator = bytecode! {
            PUSH32(word!("0x6050000000000000000000000000000000000000000000000000000000000000")) // value
            PUSH1(0x00) // offset
            MSTORE
            PUSH1(0x02) // length
            PUSH1(0x00) // offset
            RETURN
        };

        // code_a calls code_b which executes code_creator in CREATE
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH3(0x123456) // salt
            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE2

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get RETURN
        let (index_return, _) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .find(|(_, s)| s.op == OpcodeId::RETURN)
            .unwrap();
        let next_step_return =
            block.geth_trace.struct_logs.get(index_return + 1);
        let addr_expect = next_step_return.unwrap().stack.last().unwrap();

        // get CREATE2
        let step_create2 = block
            .geth_trace
            .struct_logs
            .iter()
            .find(|s| s.op == OpcodeId::CREATE2)
            .unwrap();
        let mut builder = CircuitInputBuilderTx::new(&block, step_create2);
        // Set up call context at CREATE2
        builder.state_ref().push_call(CallKind::Create, *ADDR_B);
        let addr = builder.state_ref().create2_address(step_create2).unwrap();

        assert_eq!(addr.to_word(), addr_expect);
    }

    #[test]
    fn create_address() {
        // code_creator outputs 0x6050.
        let code_creator = bytecode! {
            PUSH32(word!("0x6050000000000000000000000000000000000000000000000000000000000000")) // value
            PUSH1(0x00) // offset
            MSTORE
            PUSH1(0x02) // length
            PUSH1(0x00) // offset
            RETURN
        };

        // code_a calls code_b which executes code_creator in CREATE
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        // We do CREATE 2 times to use a nonce != 0 in the second one.
        let code_b_end = bytecode! {
            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE

            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last RETURN
        let (index_return, _) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::RETURN)
            .unwrap();
        let next_step_return =
            block.geth_trace.struct_logs.get(index_return + 1);
        let addr_expect = next_step_return.unwrap().stack.last().unwrap();

        // get last CREATE
        let step_create = block
            .geth_trace
            .struct_logs
            .iter()
            .rev()
            .find(|s| s.op == OpcodeId::CREATE)
            .unwrap();
        let mut builder = CircuitInputBuilderTx::new(&block, step_create);
        // Set up call context at CREATE
        builder.state_ref().push_call(CallKind::Create, *ADDR_B);
        builder.builder.sdb.set_account(
            &ADDR_B,
            Account {
                nonce: Word::from(1),
                balance: Word::zero(),
                storage: HashMap::new(),
                code_hash: Hash::zero(),
            },
        );
        let addr = builder.state_ref().create_address().unwrap();

        assert_eq!(addr.to_word(), addr_expect);
    }

    #[test]
    fn test_gen_access_trace() {
        use AccessValue::{Account, Code, Storage};
        use RW::{READ, WRITE};
        let ADDR_0 = address!("0x00000000000000000000000000000000c014ba5e");

        // code_a calls code_b via static call, which tries to SSTORE and fails.
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(*WORD_ADDR_B) // addr
            PUSH32(0x1_0000) // gas
            CALL

            PUSH2(0xaa)
        };
        let code_b = bytecode! {
            PUSH32(word!("0x1234567890000000000000000000abcdef000000000000000000112233445566")) // value
            PUSH1(0x01) // offset
            MSTORE
            PUSH1(0x01) // value
            PUSH1(0x02) // key
            SSTORE
            PUSH1(0x03) // key
            SLOAD

            PUSH3(0xbb)
        };
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();
        let access_trace = gen_state_access_trace(
            &block.eth_block,
            &block.eth_tx,
            &block.geth_trace,
        )
        .unwrap();

        assert_eq!(
            access_trace,
            vec![
                Access {
                    step_index: None,
                    rw: WRITE,
                    value: Account { address: ADDR_0 }
                },
                Access {
                    step_index: None,
                    rw: WRITE,
                    value: Account { address: *ADDR_A }
                },
                Access {
                    step_index: None,
                    rw: READ,
                    value: Code { address: *ADDR_A }
                },
                Access {
                    step_index: Some(7),
                    rw: WRITE,
                    value: Account { address: *ADDR_A }
                },
                Access {
                    step_index: Some(7),
                    rw: WRITE,
                    value: Account { address: *ADDR_B }
                },
                Access {
                    step_index: Some(7),
                    rw: READ,
                    value: Code { address: *ADDR_B }
                },
                Access {
                    step_index: Some(13),
                    rw: WRITE,
                    value: Storage {
                        address: *ADDR_B,
                        key: Word::from(2),
                    }
                },
                Access {
                    step_index: Some(15),
                    rw: READ,
                    value: Storage {
                        address: *ADDR_B,
                        key: Word::from(3),
                    }
                },
            ]
        );

        let access_set = AccessSet::from(access_trace);
        assert_eq!(
            access_set,
            AccessSet {
                state: HashMap::from_iter([
                    (ADDR_0, HashSet::new()),
                    (*ADDR_A, HashSet::new()),
                    (
                        *ADDR_B,
                        HashSet::from_iter([Word::from(2), Word::from(3)])
                    )
                ]),
                code: HashSet::from_iter([*ADDR_A, *ADDR_B]),
            }
        )
    }
}
